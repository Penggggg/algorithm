/**
 * 
 * @description
 * 
 * 题目：
 * 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
   给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

   输入：[2,7,9,3,1]
   输出：12
   解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
   偷窃到的最高金额 = 2 + 9 + 1 = 12 。
 */


/**
 * 
 * @description
 * 
 * 思路：
 * 一纬建模
 * 每间房间都有 偷 / 不偷的选择。
 * 
 * 房间数量1: 直接偷
 * 房间数量2：选高的偷
 * 
 * 房间数量 > 2时：
 * 对于第k（ k > 2 ）的房间。
 * 【偷】第 k间，就不能偷窃第 k-1 间，偷窃总金额为前 k-2 间的最高总金额与第 k 间房屋的金额之和。
 * 【不偷】第 k间，偷窃总金额为前 k-1 间的最高总金额。
 * 
 * 推导：dp[ i ] = Max( dp[ i - 2 ] + nums[ i ], dp[ i - 1 ])
 */

var rob = function( nums ) {

    // 特殊情况
    if ( nums.length === 0 ) return 0;

    // 每个元素都是最优解，额外搞个第0间，方便处理
    const dp = new Array( nums.length ).fill( 0 );

    // 初始化
    dp[ 0 ] = nums[ 0 ];
    for( let i = 1; i < nums.length; i++ ) {
        // 多个选择时，通过Max等比较选择最优的子问题解
        dp[ i ] = Math.max( 
            ( i - 2 < 0 ? 0 : dp[ i - 2 ]) + nums[ i ], // 偷
            dp[ i - 1 ] // 不偷
        )
    }
    return dp[ nums.length - 1 ]
};

console.log( rob([2,7,9,3,1]))