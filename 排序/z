# 介绍

> 随机写一个0到99之间的数字，如23。最多需要猜几次？

![image](https://static001.geekbang.org/resource/image/9d/9b/9dadf04cdfa7b3724e0df91da7cacd9b.jpg)

# 特点

### 类似分治思想。每次将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。

### 局限性

- 二分依赖顺序表（即数组）

> 二分查找算法需要根据下标随机访问元素。

在数组中随机访问是O( 1 )，而链表则是O( n )

因此在其他数据结构中进行二分，则时间复杂度会上升。

- 二分针对的是有序数组

> 若没有序，则需要先进行 O( nlogn )的排序

- 数据量太大不适合二分

> 因为二分依赖于数组，而数组依赖于连续空间。

数据量太大时，内存可能没有数组所需要的【连续空间】

# 核心代码

### 值得注意

- 循环退出条件

```
start <= end;
```

- mid取值

> mid=(low+high)/2是有问题的。因为如果low和high比较大的话，两者之和就有可能会溢出。

```
low = low+(high-low)/2
```

- low/high更新

```
low = mid + 1
high = mid - 1
```

### 递归实现

- 递推公式:

```
logFind( arr, start, end, num ) = logFind( arr, start2, end2, num );

终止条件：
start <= end;
```

```
const logFind = ( arr, num ) => {
    if ( arr.length === 0 || arr.length === 1 ) return -1;
    
    let s = 0;
    let e = arr.length;
    let m = Math.floor( s + (e - s) / 2 );
    
    if ( num === arr[ m ]) return m;
    if ( num < arr[ m ]) {
        return logFind( arr.slice( 0, m ), num );
    } else {
        return logFind( arr.slice( m + 1), num )
    }
}
```

### while

```
const findLog = ( arr, num ) => {
    let s = 0;
    let e = arr.length - 1;
    while ( s <= e ) {
        const m = Math.floor( s + ( s - e ) / 2 );
        if ( num === arr[ m ]) return m;
        if ( num < arr[ m ]) {
            e = m - 1;
        }
        if ( num > arr[ m ]) {
            s = m + 1;
        }
    }
    return -1;
}
```



# 二分的变形问题

> 根据题意，本质上还是对区间范围的重新锚定。到达目标条件后，根据题意，判断继续查找的方向，根据方向缩小区间（像一个蠕动的虫子），继续对比。以下给定数组，都是由小到大排序。

### 查找第一个等于给定值的元素

> 找到【等于】后，担心找到的不是“第一个”，因此需要【向前】继续查找。所以要判定前一个元素，是否存在等于情况。若存在，则start不变，缩小end“后半部分”的空间（向前）。

![image](https://static001.geekbang.org/resource/image/50/f8/503c572dd0f9d734b55f1bd12765c4f8.jpg)

- 核心代码：

```
// 遇到目标情况时：
if ( arr[ m ] === num ) {
    // 判定前一个元素
    if (( m === 0 ) || arr[ m - 1 ] !== num ) return m;
    
    // 进一步缩小“后半部分”的空间:
    else end = m - 1;
}
```

### 查找最后一个等于给定值的元素

> 找到【等于】后，担心找到的不是“最后一个”，因此需要【向后】继续查找。因此判定下一个元素，是否存在等于情况。若存在，则end不变，缩小start“前半部分”的空间（向后）

- 核心代码：

```
// 遇到目标情况时：
if ( arr[ m ] === num ) {
    // 正常情况
    if (( m === arr.length - 1 ) || arr[ m + 1 ] !== num ) return m;
    
    // 进一步缩小“前半部分”的空间:
    else start = m + 1;
}
```

# 查找第一个大于等于给定值的元素

```
[ 3，4，6，7，10 ]

第一个大于等于 5 的元素: 6
```

> 找到【大于等于】后，担心找到的不是“第一个”，因此需要【向前】继续查找。因此判定前一个元素，是否存在大于等于情况。若存在，则start不变，缩小end“后半部分”的空间（向前）

- 核心代码：

```
// 遇到目标情况时：
if ( arr[ m ] >= num ) {
    // 正常情况
    if (( m === 0 ) || arr[ m - 1 ] < num ) return m;
    
    // 进一步缩小“后半部分”的空间: 
    else end = m - 1;
}
```

