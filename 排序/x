# 简介

> 此文稿只讲O( n^2 )的排序。以及“分区”的思想

[动态查看排序过程](https://visualgo.net/zh/sorting)

![image](https://static001.geekbang.org/resource/image/fb/cd/fb8394a588b12ff6695cfd664afb17cd.jpg)

# 分析“排序”

### 执行效率

- 最好情况、最坏情况、平均情况时间复杂度

> 有序程度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道在不同数据下的性能表现。

- 时间复杂度的系数、常数 、低阶

> 实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据。所以要把系数、常数、低阶也考虑进来。

- 比较次数和交换（移动）次数

> 一些算法交互非常频繁（如冒泡），而有些算法的交换次数则很少

### 算法的内存消耗

> 即，空间复杂度。当空间复杂度是 O(1) 时，特指为原地排序。

### 排序稳定性

> 稳定性是衡量排序的重要指标。即：经过排序之后，相等元素之间原有的先后顺序不变。

# 冒泡排序

> 每一个【泡】只装载2个元素。【泡】的作用就是让泡内部值更大的那个数处于【泡】的上方。一组【冒泡】动作相当于让【最大值】坐电梯一般（不停交换），通过【泡泡】达到水面（数组顶部）

![image](https://static001.geekbang.org/resource/image/40/e9/4038f64f47975ab9f519e4f739e464e9.jpg)

```
【泡内部】核心代码：
if ( a[ j ] > a[ j + 1]) {
    // 交换
    [ a[ j + 1], a[ j ]] = [ a[ j ], a[ j + 1 ]];
}

一次【冒泡】核心代码：
for ( let j = 0; j < n - i -1; j ++ ) {
    // 泡内部
}

多组【冒泡】核心代码：
for ( let i = 0; i < n; i++ ) {
    for ( let j = 0; j < n - i -1; j ++ ) {
        // ...
    }
}
```

- 特性
  - 冒泡是原地排序，空间复杂度为 O(1)
  - 冒泡排序是稳定的排序算法

# 插入排序

> 往一个有序数组中插入一个数时，只需要找到一个“适合”它的位置，把这个位置之后元素均往后挪一个位置，腾一个空间给这个数【插入】即可。插入排序的核心，是划分“有序”、“无序”两个区域，以及“挪动”操作。

![image](https://static001.geekbang.org/resource/image/7b/a6/7b257e179787c633d2bd171a764171a6.jpg)

```
【分区】核心代码：
for( let i = 1; i < n; i++ ) { ... } // 默认a[ 0 ]是有序区

【无序区第一个元素】核心代码：
a[ i ];

【有序区最后一个元素】核心代码：
a[ i - 1 ];

【往后挪动一个位置】核心代码：
a[ j + 1 ] = a[ j ] // 往后挪动，且需要从后往前的遍历方式

【查找插入位置】核心代码：
let j = i - 1; // 有序区最后一个元素
for( ; j >= 0; j-- ) { // j在不断计算
    if ( a[ j ] < target ) break; // 找到了
}
// j => 找到了这个位置了

【边找边挪】核心代码：
let j = i - 1;
for ( ; j >= 0; j-- ) {
    if ( a[ j ] > target ) {
        a[ j + 1 ] = a[ j ]; // 挪
    } else {
        break;
    }
}
a[ j + 1 ] = target // 找到这个位置了，插入
```

- 特性
  - 插入是原地排序，空间复杂度为 O(1)
  - 插入排序是稳定的排序算法
  
![image](https://static001.geekbang.org/resource/image/b6/e1/b60f61ec487358ac037bf2b6974d2de1.jpg)


# 选择排序

> 也划分“有序”、“无序”两个区域。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾，且无序区默认为0个。

![image](https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg)

```
【无序区找最小元素】核心代码：
let minIndex = i;
for ( let j = i + 1; j < n; j++ ) {
    if ( a[ j ] < a[ i ]) {
        minIndex = j;
    }
}
```

- 特性
  - 选择排序不是稳定的排序算法

> 比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，

# 总结

### 插入排序要比冒泡排序更好

```
冒泡：3行代码、占性能
if (a[j] > a[j+1]) {
    int tmp = a[j]; 
    a[j] = a[j+1]; 
    a[j+1] = tmp; 
}

插入：
if (a[j] > value) { 
    a[j+1] = a[j];
} else break;
```

### 时间复杂度

![image](https://static001.geekbang.org/resource/image/34/50/348604caaf0a1b1d7fee0512822f0e50.jpg)




















